---
description: 当在当前会话中执行具有独立任务的实施计划时使用
---

# 子代理驱动开发

## 第一性原理

**为什么用子代理？** 上下文积累导致混乱。每个任务用新代理 = 干净的起点 + 聚焦的执行。

**核心公理：**
1. 隔离减少错误传播 - 一个任务的混乱不影响下一个
2. 两阶段审查捕获两类问题 - 需求符合性 + 代码质量
3. 新鲜视角发现盲点

## 何时使用

**适用场景：**
- 有实施计划
- 任务大多独立
- 想在当前会话中完成

**vs. 执行计划（并行会话）：**
- 同一会话（无上下文切换）
- 每个任务新代理（无上下文污染）
- 每个任务后两阶段审查
- 更快迭代（任务间无人工介入）

## 流程

### 1. 准备
- 读取计划文件，提取所有任务的完整文本
- 记录上下文，创建待办列表

### 2. 每个任务循环

```
派发实现者子代理
    ↓
子代理有问题？ → 回答问题 → 重新派发
    ↓ 无问题
子代理实现、测试、提交、自审
    ↓
派发规格审查子代理
    ↓
代码符合规格？ → 不符合 → 修复 → 重新审查
    ↓ 符合
派发代码质量审查子代理
    ↓
代码质量通过？ → 不通过 → 修复 → 重新审查
    ↓ 通过
标记任务完成
```

### 3. 完成
- 所有任务完成后，派发最终代码审查
- 使用 `finishing-a-development-branch` 完成

## 关键优势

**vs 手动执行：**
- 子代理自然遵循 TDD
- 每个任务上下文新鲜
- 并行安全（子代理不干扰）

**质量门控：**
- 自审在交接前捕获问题
- 规格符合性防止多建/少建
- 代码质量确保实现良好

## 危险信号

**绝不要：**
- 跳过审查（规格或质量）
- 带着未修复问题继续
- 并行派发多个实现子代理（冲突）
- 让子代理读计划文件（直接提供完整文本）
- 在规格合规✅之前开始代码质量审查（顺序错误）
